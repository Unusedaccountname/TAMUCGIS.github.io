<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Tamuc GIS and Data Visualizations Club</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="{{ url_for('static', filename='css/bootstrap.min.css') }}" rel="stylesheet">
	<link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">
</head>
<header>
	<div class="dropdown">
	  <button class="btn btn-default dropdown-toggle" type="button" id="dropdownMenu1" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
	    Dropdown
	    <span class="caret"></span>
	  </button>
	  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
	    <li><a href="#">Who we Are</a></li>
	    <li><a href="#">What we Do</a></li>
	    <li><a href="http://www.esri.com/what-is-gis">What is GIS?</a></li>
			<li><a href="https://opensource.com/resources/what-open-source">What is Open Source?</a></li>
	    <li role="separator" class="divider"></li>
	    <li><a href="#">Blog</a></li>
			<li role="separator" class="divider"></li>
			<li><a href="#">Source</a></li>
			<li role="separator" class="divider"></li>
			<li><a href="#">Store</a></li>
	  </ul>
	</div>
</header>
<body>
<p>
Development Blog test #1:

C++ and Qt, and porting games to iOS using Objective- C++:

For the GIS club, we are working on a set of games that show GIS principles, the first of which is to use GIS data and show the benefits thereof.
One of the main ideas that I had ws after being inspired by a game called Gwent. Being a huge fan of the witcheer series, I realized that the principles of the Gwent game, and that of the game we were making, had a common ancestor in Blackjack. 
As the lead developer for the group, there was a lot of though into what languages would ber used for development for a game that had GIS principles. 
The first that came to mind was Python, as it could integrate with QGIS and ArcGis, and provide an introduction, however, I realized that this would be something that would also have to have value to the other students that were working on this with me. 
So... next came C++. The majority of our curiculum is in C++, and the language as a whole has substantial usage in the video game industry. 
Also, the overall amount of lines of code for the main game loop, are about 150, and the pointer definitions are small. 
But there was another kicker, the ability to use the SDL to provide a graphics layer to the overall game, and to use the QT gui framework. 
Lastly, as the system itself, is going to be ported to an iOS environment, it made sense that while using a cross platform system such as Apache Cordova, would be useful, at the end of the day, we could run natively for our needs, using objective-c++.
Though I will mention, if I was to make a game by myself, I would want to have something that is a rapid environment, and be succinct enough for use for a person that may or may not have the time nor the budget to create a system in C++.
I would recommend Python through the PyGame engine, or Javascript, using React Native and the multitude of javascript libraries that would make game development easier for a developer. 
</p>
<p>
Development Blog post #2:
Java and Android:


</p>
<p>
Development Blog post #3:
Programming development environments:

I typically use one of two editors for programming, depending on the machine that I use. 
If I have to work on a resources constrained machine, I use notepad++, as it is lightweight, and I do not have to fiddle with installing packages, which could further clutter memory use. 
In most cases, Notepad++ provides enough memory leftover so I can install any debugger/intrepreter that I would need for my programming needs. 
If I have a computer with more horsepower, I will generally use Atom. I like atom as the editor overall has a smooth feel, I can integrate it directly with the Github Desktop client, and pull the code I need at any moment. 
As I work with a team, this is one of the best selling points of the editor, besides the package manager. 
I overall have had less time to worry about bug fixes, given the wide array of packages that are available for use in the system itself. 
I do all of my development work using a Windows machine, mainly given convenience, and availability. 

Though, there are users in our group that run Linux, and use editors with that, and other users that avoid editors at all cost, and use an IDE... I can say that the fact that I can pull the git items, without hassle, is what matters most. 
For C++ development, I tend to stick with Code::Blocks. Though I used Visual Studio for the majority of my C++ work early on, and have used Dev-C++, I find that code::blocks works best with my programming style, 
as well as being the most lightweight and beneficial IDE for my needs. 



</p>
<p>
Development Blog post #4:
Lisp and R, for GIS and image processing, from VR to Geospatial, and the creation of a domain specific language (or how I learned to stop worrying, and love Lisp.

One of the most interesting books that I have read recently, is called how to make a Scheme in 48 hours. 
The whole point of the book is to better learn to program in Haskell, while learning the basics of the Scheme implementation of Lisp. 
Lisp as a whole is a fantastic language, once you get used to the syntax. The main selling point of Lisp is that you can create macros, at runtime, which can increment changes to the overall codebase. 
Now the thought of being able to run a program, and change variables in the system, without bothering the code, is an interesting set to have. 
Which made me realize that the book would have more practicallity for me than just a simple exercise. 
 



</p>
<p>
Development Blog post #5:
The classic car vs buy new one theory (or how I learned to stop worrying and love old codebases)

Recently, I inherited two open source code bases in languages that are not considered the standard. 
The codebases are in Pascal and Common Lisp. 
Now, as the code bases have significant value to me, I am wondering what options I would have for this matter. 

From what I can see there are three options. 

Option 1: Update to modern standards but keep the original codebase (or in car terms, clean the car up, and keep it running)

Option 2: Change the codebase to a language that is similar, with more features (put modern compatible parts with a classic car (basically hot rodding))

Option 3: Rewrite the codebase into a completely different language that you understand (just buy a new car)

For the codebase in Pascal, we are looking around 5,000 lines of code, and for Common Lisp, around 2,000.
So the first question that I will ask, is just like if I was to work on a classic car, are there other classic cars around?
If yes, how well do they run, meaning, where do others buy parts, and how well do the users of said parts, get along with each other?

Another question to ask is are the parts universal, meaning that the design has not changed, and we can slowly implement the parts to different models?

So in the case of Common Lisp, there are two schools of thought that ended up being the most useful.

</p>
	
<p>
Development blog post #6: 
Making maps with Javascript, or Cesium, Carto, and Leaflet (oh my!)
	
We will be updating the website, so that we can use Javascript, and the javascript libraries, to run specific maps of the data that our team uses. 
The point of this is so when we have an update of data that is related to the university, we can have a mass data pull, from our database to the client. 
The libraries that we will use are: Cesium, Carto and Leaflet. 
We will be updating our maps with multiple sources, so stay tuned!
</p>
<p>
Development blog post #7:
We're all in this together, or sing a song of the JVM.
	
At the GIS Club, we have a range of members that come from a variety of backgrounds. 
These include artists, geographers, electrical engineers, data scientists, and the arts.
One of the goals that I would like to work on as the lead developer, is having these groups work together in one big project. 
The questions is thus: Everyone knows a mixture of these languages... R, Python, Javascript, Java, C, C++, Erlang... how do we mix them together?
After looking at the overall structure, the best answer is to use the JVM. The libraries for allowing integration of the above languages in some form or fashion...
Allow for a good amount of interoperatibility. 
We're not sure what the big project will be at this time, but we know for a certainty that everyone will have something to bring to the table. 
Stay tuned!
</p>
<p>
Development blog post #8:
Be a Maker.


</p>
<p>
Development blog post #9:
The power of asking.

</p>
<p>
Development blog post #10:
Use the right tool for the job
After a year of development work, and while working as a flat organization, there is one thing that readily apparent, which is this...
Use the right tool for the job. 
This is a very unusual stance to have, in a group, as the group as a whole, will go with what everyone knows. 
However, as we have found out, the right tool for the job, is the one that comes readily apparent. 
I remember watching a conference talk by Rob Pike, one of the authors of the Go language. 
He stated that all programming languages are melting together, and becoming one, which is a bad idea. 
In the group we have to work on designing Games, Mobile/Desktop Applications, and a series of web based projects. 

There are two things that tend to drive our development process, the first is does the project already exist, odds are, it does, and there is an opensource version of it. 
We make no exception, in using the open source version, whatever the license may be, and focus on the main idea of the group. 
Reinventing the wheel is the biggest time killer in regards to a project. 
	
The innovation stems from where the ideas battle it out, and mix. 
One of the projects we would like to do involves animal/environmental conservation, and if you don't have much of a budget, you get creative real fast.
Were already in the start of the project, but we realized that that the least amount of resources we needed to design our hardware, would be the most efficient.
Focusing on resource efficency threw out a lot of design choices. We needed to have something that allowed fast development, but also allowed us to use the least amount of energy.
That threw out Python (the language that everyone knows) and R (the second language that everyone knows)
So that narrowed it down to what we needed to do, either pay more for hardware, or have other  the developers work together
using something that we don't know. 
	
in the end we used C. Since the majority of the Computer Science students, had to 
learn C++ for their coursework, we realized something... C is really minimal, and that since at the end of the day, we were doing
embedded systems programming, C was the right tool for the job. 
Also, since we can run the C code on most any embedded system, we were able to scale up the amount of hardware devices, in our budget, without goingover on our price constraint.
Another added benefit of the C language, is that most other programming language has a interface to ti, soo our Code could itself to the overall solution of what we working on. 
It pays to know what the best tool for the job is.
</p>
<p>
Design thinking: Community is all:



</p>
</body>
</html>
